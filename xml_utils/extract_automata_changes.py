#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# (c) Grupo AIA
#     marinjl@aia.es
#
#
# extract_automata_changes.py: Once a case has been run in Astre and
#    Dynawo, this script extracts all relevant changes in control
#    automata and writes them out to a couple of files, for later
#    analysis. This output is standardized so that the event types and
#    the devices they refer to use the same labels, so that a
#    comparison can be made.
#
# On input, the files are expected to have this structure:
#
# CASE/
# ├── Astre
# │   └── donneesModelesEntree.xml
# ├── fic_JOB.xml
# ├── t0
# │   ├── fic_CRV.xml
# │   ├── fic_DYD.xml
# │   ├── fic_IIDM.xml
# │   └── fic_PAR.xml
# └── tFin
#    ├── fic_CRV.xml
#    ├── fic_DYD.xml
#    ├── fic_IIDM.xml
#    └── fic_PAR.xml
#
# Plus, of course, all the *output* files and directories generated by
# Astre and Dynawo.
#
#
# On output, the script generates two new output files:
#
# RUN_CASE/
# ├── Astre
# │   └── Astre_aut_changes.csv
# └── Dynawo_aut_changes.csv
#
# These output files have the following columns:
#
#    DEVICE_TYPE; DEVICE; TIME; EVENT; EVENT_MESSAGE
#
# where the EVENT labels are standardized (i.e., translated) to those
# of Dynawo, while EVENT_MESSAGE keeps the original message.
#

import sys
import os
from lxml import etree
import pandas as pd


DYD_FILE = "/tFin/fic_DYD.xml"
ASTRE_EVENTS_IN = "/Astre/donneesModelesSortie.xml"
ASTRE_EVENTS_OUT = "/Astre/Astre_automata_changes.csv"
DYNAWO_EVENTS_IN = "/tFin/outputs/timeLine/timeline.xml"
DYNAWO_EVENTS_OUT = "/Dynawo_automata_changes.csv"

verbose = False


def main():

    if len(sys.argv) != 2:
        print("\nUsage: %s run_case\n" % sys.argv[0])
        return 2
    run_case = sys.argv[1]

    # Check that all needed files are in place
    run_case, basename, dirname = check_inputfiles(run_case)
    if verbose:
        print("Extracting automata changes for case: %s" % run_case)

    # Extract the events from Astre results
    df_ast = extract_astre_events(run_case + ASTRE_EVENTS_IN)

    # Extract the events from Dynawo results
    df_dwo = extract_dynawo_events(run_case + DYNAWO_EVENTS_IN, run_case + DYD_FILE)

    # Sort and save
    save_extracted_events(
        df_ast, df_dwo, run_case + ASTRE_EVENTS_OUT, run_case + DYNAWO_EVENTS_OUT
    )

    return 0


def check_inputfiles(input_case):
    if not os.path.isdir(input_case):
        raise ValueError("source directory %s not found" % input_case)

    # remove trailing slash so that basename/dirname below behave consistently:
    if input_case[-1] == "/":
        input_case = input_case[:-1]
    basename = os.path.basename(input_case)
    dirname = os.path.dirname(input_case)
    # corner case: if called from the parent dir, dirname is empty
    if dirname == "":
        dirname = "."

    if verbose:
        print("input_case: %s" % input_case)
        print("basename: %s" % basename)
        print("dirname:  %s" % dirname)

    if not (
        os.path.isfile(input_case + ASTRE_EVENTS_IN)
        and os.path.isfile(input_case + DYNAWO_EVENTS_IN)
    ):
        raise ValueError("the expected output files are missing in %s\n" % input_case)

    return input_case, basename, dirname


def extract_astre_events(astre_input):
    tree = etree.parse(astre_input)
    root = tree.getroot()
    ns = etree.QName(root).namespace

    # We'll be using a dataframe for sorting
    column_list = ["DEVICE_TYPE", "DEVICE", "TIME", "EVENT", "EVENT_MESSAGE"]
    data = []

    # We enumerate all events and extract the types we need
    for event in root.iter("{%s}evtchronologie" % ns):
        # Transformer taps
        if event.get("type") == "9" and event.get("evenement") == "1":  # PRISEPLUS1
            append_astre_data(data, event, "TRANSFORMER", "TapUp")
        elif event.get("type") == "9" and event.get("evenement") == "2":  # PRISEMOINS1
            append_astre_data(data, event, "TRANSFORMER", "TapDown")
        # Shunts
        elif (
            event.get("type") == "4" and event.get("evenement") == "21"
        ):  # ACMC_ENCLENCHEMENT
            append_astre_data(data, event, "SHUNT", "ShuntConnected")
        elif (
            event.get("type") == "4" and event.get("evenement") == "22"
        ):  # ACMC_DECLENCHEMENT
            append_astre_data(data, event, "SHUNT", "ShuntDisconnected")
        elif (
            event.get("type") == "4" and event.get("evenement") == "33"
        ):  # SMACC_ENCLENCHEMENT
            append_astre_data(data, event, "SHUNT", "ShuntConnected")
        elif (
            event.get("type") == "4" and event.get("evenement") == "34"
        ):  # SMACC_DECLENCHEMENT
            append_astre_data(data, event, "SHUNT", "ShuntDisconnected")
        # K-levels
        elif (
            event.get("type") == "2" and event.get("evenement") == "18"
        ):  # RST_CONSIGNE
            append_astre_data(data, event, "SVC_Klevel", "NewRstLevel")

    # Translate the device IDs to their names
    astre_id2name(data, root)

    df = pd.DataFrame(data, columns=column_list)
    return df


def append_astre_data(data, event, device_type, event_name):
    # The order should match the column list in caller
    data.append(
        [
            device_type,
            event.get("ouvrage"),
            float(event.get("instant")),
            event_name,
            event.get("message"),
        ]
    )


def astre_id2name(data, tree_root):
    ns = etree.QName(tree_root).namespace

    # Build a dict: num ==> nom (we need one for each type of device)
    xfmer_names = dict()
    for xfmer in tree_root.iter("{%s}quadripole" % ns):
        xfmer_names[xfmer.get("num")] = xfmer.get("nom")

    shunt_names = dict()
    for shunt in tree_root.iter("{%s}shunt" % ns):
        shunt_names[shunt.get("num")] = shunt.get("nom")

    klevel_names = dict()
    for klevel in tree_root.iter("{%s}groupe" % ns):
        klevel_names[klevel.get("num")] = klevel.get("nom")

    # Now depending on device type (row[0]), translate the ouvrage id
    # to its name (row[1])
    for row in data:
        if row[0] == "TRANSFORMER":
            row[1] = xfmer_names.get(row[1], "**ERROR***")
        elif row[0] == "SHUNT":
            row[1] = shunt_names.get(row[1], "**ERROR***")
        elif row[0] == "SVC_Klevel":
            row[1] = klevel_names.get(row[1], "**ERROR***")


def extract_dynawo_events(dynawo_input, dynawo_dyd):
    tree = etree.parse(dynawo_input)
    root = tree.getroot()
    ns = etree.QName(root).namespace

    # We'll be using a dataframe for sorting
    column_list = ["DEVICE_TYPE", "DEVICE", "TIME", "EVENT", "EVENT_MESSAGE"]
    data = []

    # We enumerate all events and extract the types we need
    for event in root.iter("{%s}event" % ns):
        # Transformer taps
        if event.get("message") == "Tap +1":
            append_dynawo_data(data, event, "TRANSFORMER", "TapUp")
        elif event.get("message") == "Tap -1":
            append_dynawo_data(data, event, "TRANSFORMER", "TapDown")
        # Shunts
        elif event.get("message") == "SHUNT : connecting":
            append_dynawo_data(data, event, "SHUNT", "ShuntConnected")
        elif event.get("message") == "SHUNT : disconnecting":
            append_dynawo_data(data, event, "SHUNT", "ShuntDisconnected")
        elif event.get("message")[:19] == "VCS : shunt number ":
            if event.get("message")[-8:] == " closing":
                append_dynawo_data(data, event, "SHUNT", "AcmcShuntClosing")
            elif event.get("message")[-8:] == " opening":
                append_dynawo_data(data, event, "SHUNT", "AcmcShuntOpening")
        elif event.get("message")[:28] == "MVCS : closing shunt number ":
            append_dynawo_data(data, event, "SHUNT", "SmaccClosingDelayPast")
        elif event.get("message")[:28] == "MVCS : opening shunt number ":
            append_dynawo_data(data, event, "SHUNT", "SmaccOpeningDelayPast")
        # K-levels
        elif event.get("message")[:21] == "SVC Area : new level ":
            append_dynawo_data(data, event, "SVC_Klevel", "NewRstLevel")

    # Translate the dynamic model labels to their static device counterparts
    dynawo_id2name(data, dynawo_dyd)

    df = pd.DataFrame(data, columns=column_list)
    return df


def append_dynawo_data(data, event, device_type, event_name):
    # The order should match the column list in caller
    data.append(
        [
            device_type,
            event.get("modelName"),
            float(event.get("time")),
            event_name,
            event.get("message"),
        ]
    )


def dynawo_id2name(data, dynawo_dyd):
    tree = etree.parse(dynawo_dyd)
    root = tree.getroot()
    ns = etree.QName(root).namespace

    # Build a dict: "Dynamic model name" ==> "Static name" (one for ALL types)
    dm_names = dict()
    for dm in root.iter("{%s}blackBoxModel" % ns):
        static_name = dm.get("staticId")
        if static_name is not None:
            dm_names[dm.get("id")] = [dm.get("lib"), static_name]

    # Now, depending on the device type (row[0]), translate the
    # dynamic model id (row[1]) to its static name
    for row in data:
        # It seems that many (all?) TapUp/TapDown messages coming from
        # Dynamic Models are actually load-transformers, not
        # transmission transformers. So we'll also change the device
        # type to its ddb model library name, to tell them apart in
        # the output.
        if row[0] == "TRANSFORMER" and row[1][:3] == "DM_":
            row[0] = dm_names.get(row[1], ["**ERROR***", "**ERROR***"])[0]
            row[1] = dm_names.get(row[1], ["**ERROR***", "**ERROR***"])[1]


def save_extracted_events(df_ast, df_dwo, astre_output, dynawo_output):

    # Filter events. Use Panda's query() syntax (use None for no filter)
    # evt_filter = 'DEVICE_TYPE in ["TRANSFORMER", "SHUNT", "SVC_Klevel"]'
    evt_filter = 'DEVICE_TYPE in ["TRANSFORMER", "SHUNT"]'
    if evt_filter is not None:
        df_ast = df_ast.query(evt_filter)
        df_dwo = df_dwo.query(evt_filter)

    # Sort dataframe
    sort_fields = ["DEVICE_TYPE", "DEVICE", "TIME"]
    sort_order = [True, True, True]
    df_ast = df_ast.sort_values(
        by=sort_fields, ascending=sort_order, inplace=False, na_position="first"
    )
    df_dwo = df_dwo.sort_values(
        by=sort_fields, ascending=sort_order, inplace=False, na_position="first"
    )

    # Save Astre data
    df_ast.to_csv(astre_output, index=False, sep=";", encoding="utf-8")

    # Save Dynawo data
    df_dwo.to_csv(dynawo_output, index=False, sep=";", encoding="utf-8")


if __name__ == "__main__":
    sys.exit(main())
